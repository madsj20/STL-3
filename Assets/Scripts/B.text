using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using TMPro;

public class PlayerController : MonoBehaviour
{
    public Vector2Int gridPosition;           // Current grid position
    public float moveDuration = 0.5f;         // Time to move one tile

    private bool isMoving = false;
    private GridManager gridManager;
    public Vector2Int faceDirection = Vector2Int.up; // Which way the car is considered facing
    public bool isIdle => !isMoving;

    public bool useCurvedStrafes = true; // Toggle: use curves for sideways (left/right) moves

    void Start()
    {
        gridManager = FindAnyObjectByType<GridManager>();
        transform.position = new Vector3(gridPosition.x, gridPosition.y, 0);
    }

    // ===== Button actions =====
    public void MoveForward()
    {
        TryMove(faceDirection);
    }

    public void TurnLeft()   // acts as "step left" (strafe)
    {
        Vector2Int left = new Vector2Int(-faceDirection.y, faceDirection.x);
        TryMove(left);
    }

    public void TurnRight()  // acts as "step right" (strafe)
    {
        Vector2Int right = new Vector2Int(faceDirection.y, -faceDirection.x);
        TryMove(right);
    }

    // ===== Core movement chooser =====
    private bool TryMove(Vector2Int delta)
    {
        if (isMoving) return false;

        Vector2Int newPos = gridPosition + delta;
        Tile targetTile = gridManager.GetTileAtPosition(newPos);
        if (targetTile == null) return false;

        // If we’re going straight forward/back, move linearly; if sideways and toggle is on, move with a curve.
        bool isStraight = (delta == faceDirection) || (delta == -faceDirection);

        if (!isStraight && useCurvedStrafes)
            StartCoroutine(MoveToCurved(newPos, delta));
        else
            StartCoroutine(MoveToLinear(newPos, delta));

        return true;
    }

    // ===== Linear move (your original behavior, split out) =====
    private IEnumerator MoveToLinear(Vector2Int newPos, Vector2Int moveDelta)
    {
        isMoving = true;

        Vector3 start = transform.position;
        Vector3 end = new Vector3(newPos.x, newPos.y, 0f);

        // Retning for dette step (til rotation)
        Vector2 stepDir = new Vector2(moveDelta.x, moveDelta.y).normalized;

        float elapsed = 0f;
        while (elapsed < moveDuration)
        {
            float t = elapsed / moveDuration;
            transform.position = Vector3.Lerp(start, end, t);

            // Glidende rotation mod kursen
            float targetAngle = Mathf.Atan2(stepDir.y, stepDir.x) * Mathf.Rad2Deg - 90f;
            transform.rotation = Quaternion.RotateTowards(
                transform.rotation,
                Quaternion.Euler(0f, 0f, targetAngle),
                360f * Time.deltaTime / moveDuration // justér 360f for hurtigere/langsommere drej
            );

            elapsed += Time.deltaTime;
            yield return null;
        }

        // Snap til slut
        transform.position = end;
        gridPosition = newPos;

        // Vi ender med at pege i kørselsretningen
        faceDirection = moveDelta;
        float finalAngle = Mathf.Atan2(faceDirection.y, faceDirection.x) * Mathf.Rad2Deg - 90f;
        transform.rotation = Quaternion.Euler(0f, 0f, finalAngle);

        isMoving = false;
    }

    // ===================== BØJET (BÉZIER) BEVÆGELSE =====================

    private IEnumerator MoveToCurved(Vector2Int newPos, Vector2Int moveDelta)
    {
        isMoving = true;

        // Quadratic Bézier: p0 -> p2 med p1 som kontrolpunkt
        Vector3 p0 = transform.position;                 // start (nu)
        Vector3 p2 = new Vector3(newPos.x, newPos.y, 0); // slut (center af næste felt)

        // Kontrolpunkt: halvvejs i kombineret ind- og udretning (tiles er 1x1)
        Vector2 enter = new Vector2(faceDirection.x, faceDirection.y).normalized;
        Vector2 exit  = new Vector2(moveDelta.x,     moveDelta.y    ).normalized;
        Vector3 p1 = p0 + new Vector3(enter.x + exit.x, enter.y + exit.y, 0f) * 0.5f;

        // For næsten konstant fart: forprøv kurven og brug længde som tid
        const int SEGMENTS = 20; // højere = jævnere fart og rotation
        var sample = SampleQuadraticBezier(p0, p1, p2, SEGMENTS);
        List<Vector3> pts = sample.points;
        List<float> cum = sample.cumulative;

        float totalLen = cum[cum.Count - 1];
        float speed = totalLen / moveDuration;

        float elapsed = 0f;
        while (elapsed < moveDuration)
        {
            float targetDist = Mathf.Min(totalLen, elapsed * speed);

            int idx = FindSegmentIndex(cum, targetDist);
            float segStart = cum[idx];
            float segEnd   = cum[idx + 1];
            float u = (segEnd <= segStart) ? 0f : (targetDist - segStart) / (segEnd - segStart);

            Vector3 a = pts[idx];
            Vector3 b = pts[idx + 1];

            // Position
            transform.position = Vector3.Lerp(a, b, u);

            // Rotation mod tangentens retning
            Vector3 tangent3 = (b - a).normalized;
            Vector2 stepDir = new Vector2(tangent3.x, tangent3.y);
            float targetAngle = Mathf.Atan2(stepDir.y, stepDir.x) * Mathf.Rad2Deg - 90f;
            transform.rotation = Quaternion.RotateTowards(
                transform.rotation,
                Quaternion.Euler(0f, 0f, targetAngle),
                360f * Time.deltaTime / moveDuration
            );

            elapsed += Time.deltaTime;
            yield return null;
        }

        // Snap til slut
        transform.position = p2;
        gridPosition = newPos;

        // Vi ender med at pege i den retning bevægelsen gik
        faceDirection = moveDelta;
        float finalAngle = Mathf.Atan2(faceDirection.y, faceDirection.x) * Mathf.Rad2Deg - 90f;
        transform.rotation = Quaternion.Euler(0f, 0f, finalAngle);

        isMoving = false;
    }

    // ===================== KURVE-UTILS =====================

    private static Vector3 QuadraticBezier(Vector3 p0, Vector3 p1, Vector3 p2, float t)
    {
        float u = 1f - t;
        return (u * u * p0) + (2f * u * t * p1) + (t * t * p2);
    }

    private (List<Vector3> points, List<float> cumulative) SampleQuadraticBezier(
        Vector3 p0, Vector3 p1, Vector3 p2, int segments)
    {
        var pts = new List<Vector3>(segments + 1);
        var cum = new List<float>(segments + 1);

        float dist = 0f;
        Vector3 prev = p0;

        pts.Add(prev);
        cum.Add(0f);

        for (int i = 1; i <= segments; i++)
        {
            float t = i / (float)segments;
            Vector3 cur = QuadraticBezier(p0, p1, p2, t);
            dist += Vector3.Distance(prev, cur);
            pts.Add(cur);
            cum.Add(dist);
            prev = cur;
        }

        return (pts, cum);
    }

    private int FindSegmentIndex(List<float> cumulative, float distance)
    {
        // Lille lineær søgning er fin for 20 segmenter
        int i = 0;
        int last = cumulative.Count - 2;
        while (i < last && cumulative[i + 1] < distance) i++;
        return i;
    }
}
